<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas API Quiz Creator - Advanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .log-entry { transition: background-color 0.3s ease; }
        .syntax-guide { background-color: #fdfdff; border-left: 3px solid #4f46e5; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <div class="max-w-6xl mx-auto py-10 px-4">
        <header class="mb-8">
            <h1 class="text-3xl font-bold">Canvas LMS Quiz Creator</h1>
            <p class="text-gray-600 mt-2">Paste quiz text, set Canvas details, and import via API.</p>
        </header>

        <div class="bg-white p-8 rounded-lg shadow-md space-y-8">
            <div>
                <h2 class="text-2xl font-semibold border-b pb-2 mb-4">Step 1: Canvas Details</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <label for="canvasUrl" class="block text-sm font-medium text-gray-700">Canvas URL</label>
                        <input type="text" id="canvasUrl" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" placeholder="https://yourschool.instructure.com">
                    </div>
                    <div>
                        <label for="courseId" class="block text-sm font-medium text-gray-700">Course ID</label>
                        <input type="text" id="courseId" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" placeholder="e.g., 12345">
                    </div>
                    <div class="md:col-span-2">
                        <label for="apiToken" class="block text-sm font-medium text-gray-700">API Access Token</label>
                        <input type="password" id="apiToken" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm" placeholder="Paste your generated token here">
                        <p class="mt-2 text-xs text-gray-500">
                            Generate this in Canvas: Account > Settings > + New Access Token.
                        </p>
                    </div>
                </div>
            </div>

            <div>
                <h2 class="text-2xl font-semibold border-b pb-2 mb-4">Step 2: Quiz Content & Formatting</h2>
                <div class="syntax-guide p-4 mb-4 rounded-md text-sm text-gray-700">
                    <h3 class="font-semibold mb-2">Formatting Guide:</h3>
                    <ul class="list-disc list-inside space-y-1">
                        <li>Separate questions with a blank line. Use <code>//</code> for comments.</li>
                        <li><strong>Points:</strong> Use <code>// Points: 5</code> on its own line within a question block.</li>
                        <li><strong>Multiple Choice/Answers:</strong> Start correct answer(s) with <code>*</code>.</li>
                        <li><strong>True/False:</strong> Use <code>*True</code> or <code>*False</code> for the correct answer.</li>
                        <li><strong>Matching:</strong> Use the format <code>[Prompt] -> Answer</code>.</li>
                        <li><strong>Fill-in-the-Blank:</strong> Use <code>Answer:</code> lines; for multiple correct answers, separate with <code>|</code>.</li>
                        <li><strong>Essay:</strong> Write <code>[Essay Question]</code> on the line after the question prompt.</li>
                        <li><strong>Feedback:</strong> Use <code>Correct Feedback:</code> and <code>Incorrect Feedback:</code> on new lines.</li>
                    </ul>
                </div>
                <textarea id="quizText" class="block w-full h-[600px] rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 font-mono p-4" placeholder="// QUIZ TITLE: Advanced Knowledge Quiz
// QUIZ DESCRIPTION: A quiz demonstrating multiple question types and feedback.

// Question 1: Multiple Choice with Feedback
// Points: 5
What is the capital of Canada?
a. Toronto
b. Vancouver
*c. Ottawa
Correct Feedback: That's right! Ottawa is the capital.
Incorrect Feedback: Not quite. While Toronto is the largest city, Ottawa is the capital.

// Question 2: Matching with Feedback
// Points: 10
Match the element to its symbol.
[Gold] -> Au
[Silver] -> Ag
[Iron] -> Fe
Correct Feedback: Nice work matching element names to symbols.
Incorrect Feedback: Review the periodic table symbols and try again."></textarea>
            </div>

            <div class="flex items-center gap-3">
                <button id="createQuizBtn" class="px-5 py-2.5 rounded-md bg-indigo-600 hover:bg-indigo-700 text-white font-medium">Create Quiz</button>
                <button id="previewBtn" class="px-5 py-2.5 rounded-md bg-gray-100 hover:bg-gray-200 text-gray-800">Preview Payload</button>
                <a id="quizLink" href="#" target="_blank" class="hidden text-indigo-700 underline">Open Quiz</a>
            </div>

            <div>
                <h2 class="text-xl font-semibold border-b pb-2 mb-3">Logs</h2>
                <div id="log" class="bg-gray-50 border rounded-md p-3 text-sm space-y-1 h-64 overflow-auto"></div>
            </div>
        </div>
    </div>

    <script>
        const logEl = document.getElementById('log');
        const createQuizBtn = document.getElementById('createQuizBtn');
        const previewBtn = document.getElementById('previewBtn');
        const quizLinkEl = document.getElementById('quizLink');

        function logMessage(msg, level = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry px-2 py-1 rounded ${level === 'error' ? 'bg-red-50 text-red-700' : level === 'success' ? 'bg-green-50 text-green-700' : level === 'step' ? 'bg-indigo-50 text-indigo-700' : 'bg-white text-gray-700'}`;
            entry.innerHTML = msg;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function parseQuizText(raw) {
            const lines = raw.replace(/\r\n/g, '\n').split('\n');
            const quiz = { title: 'Untitled Quiz', description: '', questions: [] };

            // Extract metadata
            for (let i = 0; i < lines.length; i++) {
                const t = lines[i].trim();
                if (t.toLowerCase().startsWith('// quiz title:')) {
                    quiz.title = t.substring(14).trim();
                } else if (t.toLowerCase().startsWith('// quiz description:')) {
                    quiz.description = t.substring(20).trim();
                }
            }

            // Split blocks by blank lines
            const blocks = raw.split(/\n\s*\n/g).map(b => b.trim()).filter(Boolean);

            for (const block of blocks) {
                if (block.toLowerCase().startsWith('// quiz')) continue; // skip metadata block(s)

                const allLines = block.split('\n');
                const question = { type: 'multiple_choice_question', text: '', points: 1, data: [], correctFeedback: '', incorrectFeedback: '' };

                // Extract points and text
                let questionText = '';
                let questionTextFound = false;
                const answerLines = [];

                allLines.forEach(line => {
                    const trimmedLine = line.trim();
                    if (trimmedLine.startsWith('//')) {
                        if (trimmedLine.toLowerCase().startsWith('// points:')) {
                            question.points = parseInt(trimmedLine.substring(10).trim()) || 1;
                        }
                    } else if (!questionTextFound) {
                        questionText = trimmedLine;
                        question.text = questionText;
                        questionTextFound = true;
                    } else {
                        if (trimmedLine.toLowerCase().startsWith('correct feedback:')) {
                            question.correctFeedback = trimmedLine.substring(17).trim();
                        } else if (trimmedLine.toLowerCase().startsWith('incorrect feedback:')) {
                            question.incorrectFeedback = trimmedLine.substring(19).trim();
                        } else {
                            answerLines.push(trimmedLine);
                        }
                    }
                });

                if (!question.text) continue;

                // Determine type
                if (answerLines.some(a => a.includes('->'))) {
                    // Matching
                    question.type = 'matching_question';
                    question.data = answerLines.map((a, i) => {
                        const parts = a.split('->');
                        return { id: i, prompt: parts[0].trim().replace(/^\[/, '').replace(/\]$/, ''), answer: parts[1].trim() };
                    });
                } else if (answerLines.length === 1 && /^\[(essay|Essay) Question\]/.test(answerLines[0])) {
                    question.type = 'essay_question';
                } else if (answerLines.length === 1 && /^answer:/i.test(answerLines[0])) {
                    // Fill-in-the-blank â†’ short_answer_question
                    question.type = 'short_answer_question';
                    const ansRaw = answerLines[0].split(':')[1] || '';
                    question.data = ansRaw.split('|').map(s => s.trim()).filter(Boolean);
                } else if (answerLines.length === 1 && (/^\*?(True|False)$/i).test(answerLines[0])) {
                    question.type = 'true_false_question';
                    question.data = [{ text: 'True', isCorrect: /^\*?true$/i.test(answerLines[0]) }];
                } else {
                    // Multiple choice/answers
                    const choices = answerLines
                        .filter(Boolean)
                        .map(l => ({ text: l.replace(/^\*/, '').replace(/^[a-d]\.\s*/i, ''), isCorrect: l.trim().startsWith('*') }));

                    const correctCount = choices.filter(c => c.isCorrect).length;
                    question.type = correctCount > 1 ? 'multiple_answers_question' : 'multiple_choice_question';
                    question.data = choices;
                }

                quiz.questions.push(question);
            }

            return quiz;
        }

        function buildQuestionPayload(question) {
            const payload = {
                question_name: question.text.substring(0, 50),
                question_text: `<p>${question.text}</p>`,
                points_possible: question.points,
                question_type: question.type,
                answers: []
            };

            if (question.correctFeedback) payload.correct_comments_html = `<p>${question.correctFeedback}</p>`;
            if (question.incorrectFeedback) payload.incorrect_comments_html = `<p>${question.incorrectFeedback}</p>`;

            switch(question.type) {
                case 'multiple_choice_question':
                case 'multiple_answers_question':
                case 'true_false_question':
                    payload.answers = question.data.map(choice => ({
                        answer_html: `<p>${choice.text}</p>`,
                        answer_weight: choice.isCorrect ? 100 : 0
                    }));
                    break;
                case 'matching_question':
                    // FIX: Canvas expects answer_text/answer_html for left-side prompts
                    payload.answers = question.data.map(match => ({
                        id: match.id,
                        answer_text: match.prompt,
                        answer_html: `<p>${match.prompt}</p>`,
                        match_id: match.id + 1000
                    }));
                    payload.matches = question.data.map(match => ({
                        text: match.answer,
                        match_id: match.id + 1000
                    }));
                    break;
                case 'short_answer_question':
                     payload.answers = question.data.map(answerText => ({
                        answer_text: answerText,
                        answer_weight: 100
                    }));
                    break;
                case 'essay_question':
                    // No answers needed; move feedback to neutral if provided
                    if (question.correctFeedback) {
                        payload.neutral_comments_html = `<p>${question.correctFeedback}</p>`;
                        delete payload.correct_comments_html;
                    }
                    break;
                default:
                    break;
            }

            return payload;
        }

        // Preview payload in logs
        previewBtn.addEventListener('click', () => {
            const quizText = document.getElementById('quizText').value;
            const parsedQuiz = parseQuizText(quizText);
            logMessage(`<strong>Preview:</strong> Title: ${parsedQuiz.title}; Questions: ${parsedQuiz.questions.length}`, 'step');
            parsedQuiz.questions.forEach((q, i) => {
                const payload = buildQuestionPayload(q);
                logMessage(`<pre class="whitespace-pre-wrap">${escapeHtml(JSON.stringify(payload, null, 2))}</pre>`);
                // Guardrail: warn if matching answers missing answer_text/answer_html
                if (q.type === 'matching_question') {
                    const bad = (payload.answers || []).some(a => !('answer_text' in a) && !('answer_html' in a));
                    if (bad) logMessage('âš ï¸ Matching answer missing answer_text/answer_html', 'error');
                }
            });
        });

        // Create quiz flow
        createQuizBtn.addEventListener('click', async () => {
            const canvasUrl = document.getElementById('canvasUrl').value.trim().replace(/\/+$/, '');
            const courseId = document.getElementById('courseId').value.trim();
            const apiToken = document.getElementById('apiToken').value.trim();
            const quizText = document.getElementById('quizText').value;

            if (!canvasUrl || !courseId || !apiToken) {
                logMessage('Please fill Canvas URL, Course ID, and API Token.', 'error');
                return;
            }

            const parsedQuiz = parseQuizText(quizText);
            logMessage(`Found ${parsedQuiz.questions.length} questions. Starting process...`);

            try {
                logMessage('Step 1: Creating Quiz Shell...', 'step');
                const quizShellData = { quiz: { title: parsedQuiz.title, description: parsedQuiz.description, quiz_type: 'assignment' }};
                const quizResponse = await apiCall(`/api/v1/courses/${courseId}/quizzes`, 'POST', apiToken, canvasUrl, quizShellData);
                const quizId = quizResponse.id;
                logMessage(`Success! Quiz shell created with ID: ${quizId}`, 'success');

                if (parsedQuiz.questions.length > 0) {
                    logMessage('Step 2: Adding questions to the quiz...', 'step');
                    for (let i = 0; i < parsedQuiz.questions.length; i++) {
                        const q = parsedQuiz.questions[i];
                        logMessage(`Creating Question ${i + 1} (${q.type}) worth ${q.points} points...`);
                        const questionPayload = buildQuestionPayload(q);
                        await apiCall(`/api/v1/courses/${courseId}/quizzes/${quizId}/questions`, 'POST', apiToken, canvasUrl, { question: questionPayload });
                        logMessage(`  -> Question ${i + 1} created successfully.`, 'success');
                    }
                }

                logMessage('------------------------------------', 'step');
                logMessage(`ðŸŽ‰ All done! Your quiz is ready in Canvas.`, 'success');
                const url = `${canvasUrl}/courses/${courseId}/quizzes`;
                quizLinkEl.href = url;
                quizLinkEl.classList.remove('hidden');
                quizLinkEl.textContent = 'Open Quiz List';
                logMessage(`View it at: <a href="${url}" target="_blank">${url}</a>`, 'success');

            } catch (error) {
                logMessage(`An error occurred: ${error.message}`, 'error');
            } finally {
                createQuizBtn.disabled = false;
            }
        });

        function escapeHtml(str) {
            return str.replace(/[&<>"']/g, function(m) {
                return ({
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                })[m];
            });
        }

        // ---- API Helper via proxy route ----
        async function apiCall(endpoint, method, token, baseUrl, body) {
            const proxyUrl = '/api/proxy'; // Your Vercel/Next API route

            const response = await fetch(proxyUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    canvasUrl: baseUrl,
                    endpoint: endpoint,
                    apiToken: token,
                    method: method,
                    body: body
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: 'Unknown error from proxy' }));
                const errorMessage = errorData.errors?.[0]?.message || errorData.message || response.statusText;
                throw new Error(`API Error (${response.status}): ${errorMessage}`);
            }

            if (response.status === 204) return { success: true };
            return response.json();
        }
    </script>
</body>
</html>
